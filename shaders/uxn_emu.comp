#version 450
//
// Created by Andrei Ghita
// Based on the UXN emulator from https://wiki.xxiivv.com/site/uxn.html
//

layout(std140, binding = 0) buffer UXN_Buffer {
    uint pc;
    uint ram[65536];
    uint wst[256];  // working stack
    uint pWst;
    uint rst[256];  // return stack
    uint pRst;
    uint dev[256];  // device data
    uint deviceFlags;
} uxn;

layout (local_size_x = 1) in;

/* VM Registry State */
struct State {
    uint a, b, c;
    uvec2 x, y, z;
};

/* Unroll */
#define OPC(opc, init, body) \
	case 0x00|opc: {const int _2=0,_r=0;init body;} break;\
	case 0x20|opc: {const int _2=1,_r=0;init body;} break;\
	case 0x40|opc: {const int _2=0,_r=1;init body;} break;\
	case 0x60|opc: {const int _2=1,_r=1;init body;} break;\
	case 0x80|opc: {const int _2=0,_r=0;uint k=uxn.pWst;init uxn.pWst=k;body;} break;\
	case 0xa0|opc: {const int _2=1,_r=0;uint k=uxn.pWst;init uxn.pWst=k;body;} break;\
	case 0xc0|opc: {const int _2=0,_r=1;uint k=uxn.pRst;init uxn.pRst=k;body;} break;\
	case 0xe0|opc: {const int _2=1,_r=1;uint k=uxn.pRst;init uxn.pRst=k;body;} break;\

/* Microcode */
void push_wst(uint i) {
    uxn.wst[uxn.pWst] = i;
    uxn.pWst++;
}

void push_rst(uint i) {
    uxn.rst[uxn.pRst] = i;
    uxn.pRst++;
}

uint pop_wst() {
    uxn.pWst--;
    return uxn.wst[uxn.pWst];
}

uint pop_rst() {
    uxn.pRst--;
    return uxn.rst[uxn.pRst];
}

void RP1(uint i, int _r) {
    if(_r != 0) {
        push_wst(i);
    } else {
        push_rst(i);
    }
}

void JMP(uint i, int _2) {
    uxn.pc = (_2 != 0) ? i : uxn.pc + i;
}

uint PO1(int _r) {
    return (_r != 0) ? pop_rst() : pop_wst();
}

uint PO2(int _r) {
    return (_r != 0) ? pop_rst() | pop_rst() << 8 : pop_wst() | pop_wst() << 8;
}

void PU1(uint i, int _r) {
    if(_r != 0) {
        push_rst(i);
    } else {
        push_wst(i);
    }
}

void PUT(uvec2 i, int _r, int _2) {
    PU1(i.x, _r);
    if (_2 != 0) {
        PU1(i.y, _r);
    }
}

void POK(uint i, uvec2 j, uint m, int _r, int _2) {
    uxn.ram[i] = j.x;
    if(_2 != 0) {
        uxn.ram[(i + 1) & m] = j.y;
    }
}

uvec2 PEK(uint i, uvec2 o, uint m, int _r, int _2) {
    // #define PEK(i,o,m) o[0] = uxn.ram[i]; if(_2 != 0) o[1] = uxn.ram[(i + 1) & m]; PUT(o)
    o.x = uxn.ram[i];
    if (_2 != 0) {
        o.y = uxn.ram[(i + 1) & m];
    }
    PUT(o,_r,_2);
    return o;
}

uvec2 GET(uvec2 prev, int _r, int _2) {
    if(_2 != 0) {
        uint t = PO1(_r);
        return uvec2(PO1(_r), t);
    } else {
        return uvec2(PO1(_r), prev.y);
    }
}

State JMI(State s) {
    s.a = uxn.ram[uxn.pc] << 8 | uxn.ram[uxn.pc + 1];
    uxn.pc += s.a + 2;
    return s;
}

void REM(int _r, int _2) {
    if(_r != 0) {
        uxn.pRst -= 1 + _2;
    } else {
        uxn.pWst -= 1 + _2;
    }
}

uint POx(int _r, int _2) {
    if(_2 != 0) {
        return PO2(_r);
    } else {
        return PO1(_r);
    }
}

State PUx(State s, uint i, int _r, int _2) {
    if (_2 != 0) {
        s.c = i;
        PU1(s.c >> 8, _r);
        PU1(s.c, _r);
    } else {
        PU1(i, _r);
    }
    return s;
}

/* Devices */
// input from device
uvec2 DEI(uint addr, uvec2 o, int _r, int _2) {
    o.x = uxn.dev[24 >> addr];
    if (_2 != 0) {
        o.y = uxn.dev[24 >> (addr + 1)];
    }
    PUT(o,_r,_2);
    return o;
}

// output to device
void DEO(uint addr, uvec2 v, int _2) {
    uxn.deviceFlags = 1;
    uxn.dev[24 >> addr] = v.x;
    if (_2 != 0) {
        uxn.dev[24 >> (addr + 1)] = v.y;
    }
}

int uxn_eval(State state) {
	if((uxn.pc == 0) || (uxn.dev[0x0f] != 0)) return 0;
	switch(uxn.ram[uxn.pc++]) {
    /* BRK */ case 0x00000000: return 1;
    /* JCI */ case 0x20000000:
                if(pop_wst() != 0) { state = JMI(state); }
                else { uxn.pc += 2; }
                break;
    /* JMI */ case 0x40000000: state = JMI(state); break;
    /* JSI */ case 0x60000000:
                state.c = uxn.pc + 2;
                push_rst(state.c >> 8);
                push_rst(state.c);
                state = JMI(state); break;
    /* LI2 */ case 0xa0000000: push_wst(uxn.ram[uxn.pc++]); /* fall-through */
    /* LIT */ case 0x80000000: push_wst(uxn.ram[uxn.pc++]); break;
    /* L2r */ case 0xe0000000: push_rst(uxn.ram[uxn.pc++]); /* fall-through */
    /* LIr */ case 0xc0000000: push_rst(uxn.ram[uxn.pc++]); break;
    /* INC */ OPC(0x01000000, state.a = POx(_r, _2);, state = PUx(state, state.a + 1, _r, _2);)
    /* POP */ OPC(0x02000000, REM(_r, _2);, {})
    /* NIP */ OPC(0x03000000,
                  state.x = GET(state.x, _r, _2); REM(_r, _2); ,
                  PUT(state.x, _r, _2); )
    /* SWP */ OPC(0x04000000,
                  state.x = GET(state.x, _r, _2); state.y = GET(state.y, _r, _2); ,
                  PUT(state.x, _r, _2); PUT(state.y, _r, _2); )
    /* ROT */ OPC(0x05000000,
                  state.x = GET(state.x,_r,_2);
                  state.y = GET(state.y,_r,_2);
                  state.z = GET(state.z,_r,_2); ,
                  PUT(state.y,_r,_2);
                  PUT(state.x,_r,_2);
                  PUT(state.z,_r,_2); )
    /* DUP */ OPC(0x06000000,
                  state.x = GET(state.x,_r,_2); ,
                  PUT(state.x,_r,_2);
                  PUT(state.x,_r,_2); )
    /* OVR */ OPC(0x07000000,
                  state.x = GET(state.x,_r,_2); state.y = GET(state.y,_r,_2); ,
                  PUT(state.y,_r,_2); PUT(state.x,_r,_2); PUT(state.y,_r,_2); )
    /* EQU */ OPC(0x08000000,
                  state.a = POx(_r,_2); state.b = POx(_r,_2); ,
                  if (state.b == state.a) { PU1(1,_r); }
                  else { PU1(0,_r); })
    /* NEQ */ OPC(0x09000000,
                  state.a = POx(_r,_2); state.b = POx(_r,_2); ,
                  if (state.b != state.a) { PU1(1,_r); }
                  else { PU1(0,_r); })
    /* GTH */ OPC(0x0a000000,
                  state.a = POx(_r,_2); state.b = POx(_r,_2); ,
                  if (state.b > state.a) { PU1(1,_r); }
                  else { PU1(0,_r); })
    /* LTH */ OPC(0x0b000000,
                  state.a = POx(_r,_2); state.b = POx(_r,_2); ,
                  if (state.b < state.a) { PU1(1,_r); }
                  else { PU1(0,_r); })
    /* JMP */ OPC(0x0c000000,
                  state.a = POx(_r,_2); ,
                  JMP(state.a, _2); )
    /* JCN */ OPC(0x0d000000,
                  state.a = POx(_r,_2); state.b = PO1(_r); ,
                  if(state.b != 0) { JMP(state.a, _2); })
    /* JSR */ OPC(0x0e000000,
                  state.a = POx(_r,_2); ,
                  RP1(uxn.pc >> 8,_r); RP1(uxn.pc,_r); JMP(state.a, _2); )
    /* STH */ OPC(0x0f000000,
                  state.x = GET(state.x,_r,_2); ,
                  RP1(state.x.x,_r);
                  if(_2 != 0) { RP1(state.x.y,_r); })
    /* LDZ */ OPC(0x10000000,
                  state.a = PO1(_r); ,
                  state.x = PEK(state.a, state.x, 0xff000000, _r, _2); )
    /* STZ */ OPC(0x11000000,
                  state.a = PO1(_r); state.y = GET(state.y,_r,_2); ,
                  POK(state.a, state.y, 0xff000000, _r, _2); )
    /* LDR */ OPC(0x12000000,
                  state.a = PO1(_r); ,
                  state.x = PEK(uxn.pc + state.a, state.x, 0xffff0000, _r,_2); )
    /* STR */ OPC(0x13000000,
                  state.a = PO1(_r); state.y = GET(state.y,_r,_2); ,
                  POK(uxn.pc + state.a, state.y, 0xffff0000, _r,_2); )
    /* LDA */ OPC(0x14000000,
                  state.a = PO2(_r); ,
                  state.x = PEK(state.a, state.x, 0xffff, _r,_2); )
    /* STA */ OPC(0x15000000,
                  state.a = PO2(_r); state.y = GET(state.y,_r,_2); ,
                  POK(state.a, state.y, 0xffff0000, _r,_2); )
    /* DEI */ OPC(0x16000000,
                  state.a = PO1(_r); ,
                  state.x = DEI(state.a, state.x, _r,_2); )
    /* DEO */ OPC(0x17000000,
                  state.a = PO1(_r); state.y = GET(state.y,_r,_2); ,
                  DEO(state.a, state.y, _2); )
    /* ADD */ OPC(0x18000000,
                  state.a = POx(_r,_2); state.b = POx(_r,_2); ,
                  state = PUx(state, state.b + state.a, _r,_2); )
    /* SUB */ OPC(0x19000000,
                  state.a = POx(_r,_2); state.b = POx(_r,_2); ,
                  state = PUx(state, state.b - state.a, _r,_2); )
    /* MUL */ OPC(0x1a000000,
                  state.a = POx(_r,_2); state.b = POx(_r,_2); ,
                  state = PUx(state, state.b * state.a, _r,_2); )
    /* DIV */ OPC(0x1b000000,
                  state.a = POx(_r,_2); state.b = POx(_r,_2); ,
                  state = PUx(state, (state.a!=0) ? state.b / state.a : 0, _r,_2); )
    /* AND */ OPC(0x1c000000,
                  state.a = POx(_r,_2); state.b = POx(_r,_2); ,
                  state = PUx(state, state.a & state.b, _r,_2); )
    /* ORA */ OPC(0x1d000000,
                  state.a = POx(_r,_2); state.b = POx(_r,_2); ,
                  state = PUx(state, state.a | state.b, _r,_2); )
    /* EOR */ OPC(0x1e000000,
                  state.a = POx(_r,_2); state.b = POx(_r,_2); ,
                  state = PUx(state, state.a ^ state.b, _r,_2); )
    /* SFT */ OPC(0x1f000000,
                  state.a = PO1(_r); state.b = POx(_r,_2); ,
                  state = PUx(state, state.b >> (state.a & 0xf000000) << (state.a >> 4), _r,_2); )
              default: break;
	}
	return 2;
}

void main() {
    State state = {0, 0, 0, uvec2(0,0), uvec2(0,0), uvec2(0,0)};
    uxn.deviceFlags = 0;

    // Run the next Uxn instruction
    uxn_eval(state);

    // Test memory offsets and strides with this:
    // uxn.ram[0] = 1;
    // uxn.ram[65535] = 1;
    // uxn.wst[0] = 1;
    // uxn.wst[255] = 1;
    // uxn.rst[0] = 1;
    // uxn.rst[255] = 0xffffffff;
    // uxn.dev[0] = 0xffffffff;
    // uxn.dev[255] = 0xffffffff;
}
