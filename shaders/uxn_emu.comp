#version 450
//
// Created by Andrei Ghita
// Based on the UXN emulator from https://wiki.xxiivv.com/site/uxn.html
//

struct stack {
    uint dat[256];
	uint ptr;
};

layout(std140, binding = 0) buffer UXN_Buffer {
    uint ram[65536];
    stack wst;  // working stack
    stack rst;  // return stack
    uint dev[256];  // todo device data
    uint pc;
} uxn;

layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

/* Devices */
// device in
uint emu_dei(uint addr) {
	return uxn.dev[addr];
}

// device out
void emu_deo(uint addr, uint value) {
	uxn.dev[addr] = value;
	// these are commented because they could very easily overwrite other data
	// especially when value was a uint8 casted into uint32
	// uxn.dev[addr+1] = value << 8;
	// uxn.dev[addr+2] = value << 16;
	// uxn.dev[addr+3] = value << 24;
}

/* Unroll */
#define OPC(opc, init, body) \
	case 0x00|opc: {const int _2=0,_r=0;init body;} break;\
	case 0x20|opc: {const int _2=1,_r=0;init body;} break;\
	case 0x40|opc: {const int _2=0,_r=1;init body;} break;\
	case 0x60|opc: {const int _2=1,_r=1;init body;} break;\
	case 0x80|opc: {const int _2=0,_r=0;uint k=uxn.wst.ptr;init uxn.wst.ptr=k;body;} break;\
	case 0xa0|opc: {const int _2=1,_r=0;uint k=uxn.wst.ptr;init uxn.wst.ptr=k;body;} break;\
	case 0xc0|opc: {const int _2=0,_r=1;uint k=uxn.rst.ptr;init uxn.rst.ptr=k;body;} break;\
	case 0xe0|opc: {const int _2=1,_r=1;uint k=uxn.rst.ptr;init uxn.rst.ptr=k;body;} break;\

/* Microcode */
#define INC(s) uxn.s.dat[uxn.s.ptr++]
#define DEC(s) uxn.s.dat[--uxn.s.ptr]

struct State {
    uint a, b, c;
    uvec2 x, y, z;
};

void RP1(uint i, int _r) {
    if(_r != 0) {
        INC(wst) = i;
    } else {
        INC(rst) = i;
    }
}

void JMP(uint i, int _2) {
    uxn.pc = (_2 != 0) ? i : uxn.pc + i;
}

uint PO1(int _r) {
    return (_r != 0) ? DEC(rst) : DEC(wst);
}

uint PO2(int _r) {
    return (_r != 0) ? DEC(rst) | DEC(rst) << 8 : DEC(wst) | DEC(wst) << 8;
}

void PU1(uint i, int _r) {
    if(_r != 0) {
        INC(rst) = i;
    } else {
        INC(wst) = i;
    }
}

void PUT(uvec2 i, int _r, int _2) {
    PU1(i.x, _r);
    if (_2 != 0) {
        PU1(i.y, _r);
    }
}

uvec2 DEI(uint i, uvec2 o, int _r, int _2) {
    o.x = emu_dei(i);
    if (_2 != 0) {
        o.y = emu_dei(i + 1);
    }
    PUT(o,_r,_2);
    return o;
}

void DEO(uint i, uvec2 j, int _2) {
    emu_deo(i, j.x);
    if (_2 != 0) {
        emu_deo(i + 1, j.y);
    }
}

void POK(uint i, uvec2 j, uint m, int _r, int _2) {
    uxn.ram[i] = j.x;
    if(_2 != 0) {
        uxn.ram[(i + 1) & m] = j.y;
    }
}

uvec2 PEK(uint i, uvec2 o, uint m, int _r, int _2) {
    // #define PEK(i,o,m) o[0] = uxn.ram[i]; if(_2 != 0) o[1] = uxn.ram[(i + 1) & m]; PUT(o)
    o.x = uxn.ram[i];
    if (_2 != 0) {
        o.y = uxn.ram[(i + 1) & m];
    }
    PUT(o,_r,_2);
    return o;
}

uvec2 GET(uvec2 prev, int _r, int _2) {
    if(_2 != 0) {
        uint t = PO1(_r);
        return uvec2(PO1(_r), t);
    } else {
        return uvec2(PO1(_r), prev.y);
    }
}

State JMI(State s) {
    s.a = uxn.ram[uxn.pc] << 8 | uxn.ram[uxn.pc + 1];
    uxn.pc += s.a + 2;
    return s;
}

void REM(int _r, int _2) {
    if(_r != 0) {
        uxn.rst.ptr -= 1 + _2;
    } else {
        uxn.wst.ptr -= 1 + _2;
    }
}

uint POx(int _r, int _2) {
    if(_2 != 0) {
        return PO2(_r);
    } else {
        return PO1(_r);
    }
}

State PUx(State s, uint i, int _r, int _2) {
    if (_2 != 0) {
        s.c = i;
        PU1(s.c >> 8, _r);
        PU1(s.c, _r);
    } else {
        PU1(i, _r);
    }
    return s;
}

int uxn_eval(State state) {
	if((uxn.pc == 0) || (uxn.dev[0x0f] != 0)) return 0;
	uxn.pc++;
	switch(uxn.ram[uxn.pc]) {
    /* BRK */ case 0x00000000: return 1;
    /* JCI */ case 0x20000000:
                if(DEC(wst) != 0) { state = JMI(state); }
                else { uxn.pc += 2; }
                break;
    /* JMI */ case 0x40000000: state = JMI(state); break;
    /* JSI */ case 0x60000000:
                state.c = uxn.pc + 2;
                INC(rst) = state.c >> 8;
                INC(rst) = state.c;
                state = JMI(state); break;
    /* LI2 */ case 0xa0000000: INC(wst) = uxn.ram[uxn.pc++]; /* fall-through */
    /* LIT */ case 0x80000000: INC(wst) = uxn.ram[uxn.pc++]; break;
    /* L2r */ case 0xe0000000: INC(rst) = uxn.ram[uxn.pc++]; /* fall-through */
    /* LIr */ case 0xc0000000: INC(rst) = uxn.ram[uxn.pc++]; break;
    /* INC */ OPC(0x01000000, state.a = POx(_r, _2);, state = PUx(state, state.a + 1, _r, _2);)
    /* POP */ OPC(0x02000000, REM(_r, _2);, {})
    /* NIP */ OPC(0x03000000,
                  state.x = GET(state.x, _r, _2); REM(_r, _2); ,
                  PUT(state.x, _r, _2); )
    /* SWP */ OPC(0x04000000,
                  state.x = GET(state.x, _r, _2); state.y = GET(state.y, _r, _2); ,
                  PUT(state.x, _r, _2); PUT(state.y, _r, _2); )
    /* ROT */ OPC(0x05000000,
                  state.x = GET(state.x,_r,_2);
                  state.y = GET(state.y,_r,_2);
                  state.z = GET(state.z,_r,_2); ,
                  PUT(state.y,_r,_2);
                  PUT(state.x,_r,_2);
                  PUT(state.z,_r,_2); )
    /* DUP */ OPC(0x06000000,
                  state.x = GET(state.x,_r,_2); ,
                  PUT(state.x,_r,_2);
                  PUT(state.x,_r,_2); )
    /* OVR */ OPC(0x07000000,
                  state.x = GET(state.x,_r,_2); state.y = GET(state.y,_r,_2); ,
                  PUT(state.y,_r,_2); PUT(state.x,_r,_2); PUT(state.y,_r,_2); )
    /* EQU */ OPC(0x08000000,
                  state.a = POx(_r,_2); state.b = POx(_r,_2); ,
                  if (state.b == state.a) { PU1(1,_r); }
                  else { PU1(0,_r); })
    /* NEQ */ OPC(0x09000000,
                  state.a = POx(_r,_2); state.b = POx(_r,_2); ,
                  if (state.b != state.a) { PU1(1,_r); }
                  else { PU1(0,_r); })
    /* GTH */ OPC(0x0a000000,
                  state.a = POx(_r,_2); state.b = POx(_r,_2); ,
                  if (state.b > state.a) { PU1(1,_r); }
                  else { PU1(0,_r); })
    /* LTH */ OPC(0x0b000000,
                  state.a = POx(_r,_2); state.b = POx(_r,_2); ,
                  if (state.b < state.a) { PU1(1,_r); }
                  else { PU1(0,_r); })
    /* JMP */ OPC(0x0c000000,
                  state.a = POx(_r,_2); ,
                  JMP(state.a, _2); )
    /* JCN */ OPC(0x0d000000,
                  state.a = POx(_r,_2); state.b = PO1(_r); ,
                  if(state.b != 0) { JMP(state.a, _2); })
    /* JSR */ OPC(0x0e000000,
                  state.a = POx(_r,_2); ,
                  RP1(uxn.pc >> 8,_r); RP1(uxn.pc,_r); JMP(state.a, _2); )
    /* STH */ OPC(0x0f000000,
                  state.x = GET(state.x,_r,_2); ,
                  RP1(state.x.x,_r);
                  if(_2 != 0) { RP1(state.x.y,_r); })
    /* LDZ */ OPC(0x10000000,
                  state.a = PO1(_r); ,
                  state.x = PEK(state.a, state.x, 0xff000000, _r, _2); )
    /* STZ */ OPC(0x11000000,
                  state.a = PO1(_r); state.y = GET(state.y,_r,_2); ,
                  POK(state.a, state.y, 0xff000000, _r, _2); )
    /* LDR */ OPC(0x12000000,
                  state.a = PO1(_r); ,
                  state.x = PEK(uxn.pc + state.a, state.x, 0xffff0000, _r,_2); )
    /* STR */ OPC(0x13000000,
                  state.a = PO1(_r); state.y = GET(state.y,_r,_2); ,
                  POK(uxn.pc + state.a, state.y, 0xffff0000, _r,_2); )
    /* LDA */ OPC(0x14000000,
                  state.a = PO2(_r); ,
                  state.x = PEK(state.a, state.x, 0xffff, _r,_2); )
    /* STA */ OPC(0x15000000,
                  state.a = PO2(_r); state.y = GET(state.y,_r,_2); ,
                  POK(state.a, state.y, 0xffff0000, _r,_2); )
    /* DEI */ OPC(0x16000000,
                  state.a = PO1(_r); ,
                  state.x = DEI(state.a, state.x, _r,_2); )
    /* DEO */ OPC(0x17000000,
                  state.a = PO1(_r); state.y = GET(state.y,_r,_2); ,
                  DEO(state.a, state.y, _2); )
    /* ADD */ OPC(0x18000000,
                  state.a = POx(_r,_2); state.b = POx(_r,_2); ,
                  state = PUx(state, state.b + state.a, _r,_2); )
    /* SUB */ OPC(0x19000000,
                  state.a = POx(_r,_2); state.b = POx(_r,_2); ,
                  state = PUx(state, state.b - state.a, _r,_2); )
    /* MUL */ OPC(0x1a000000,
                  state.a = POx(_r,_2); state.b = POx(_r,_2); ,
                  state = PUx(state, state.b * state.a, _r,_2); )
    /* DIV */ OPC(0x1b000000,
                  state.a = POx(_r,_2); state.b = POx(_r,_2); ,
                  state = PUx(state, (state.a!=0) ? state.b / state.a : 0, _r,_2); )
    /* AND */ OPC(0x1c000000,
                  state.a = POx(_r,_2); state.b = POx(_r,_2); ,
                  state = PUx(state, state.a & state.b, _r,_2); )
    /* ORA */ OPC(0x1d000000,
                  state.a = POx(_r,_2); state.b = POx(_r,_2); ,
                  state = PUx(state, state.a | state.b, _r,_2); )
    /* EOR */ OPC(0x1e000000,
                  state.a = POx(_r,_2); state.b = POx(_r,_2); ,
                  state = PUx(state, state.a ^ state.b, _r,_2); )
    /* SFT */ OPC(0x1f000000,
                  state.a = PO1(_r); state.b = POx(_r,_2); ,
                  state = PUx(state, state.b >> (state.a & 0xf000000) << (state.a >> 4), _r,_2); )
              default: break;
	}
	return 2;
}

void main() {
    //State state = {0, 0, 0, uvec2(0,0), uvec2(0,0), uvec2(0,0)};
    // this runs one uxn instruction
    uxn.pc = uxn.pc+1; //TODO: remove this line
    //uxn.dev[uxn.pc - 0x100] = uxn_eval(state);
}
