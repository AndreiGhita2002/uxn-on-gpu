#version 450

layout(std140, binding = 0) buffer UXN_Buffer {
    uint pc;
    uint ram[65536];
    uint wst[256];  // working stack
    uint pWst;
    uint rst[256];  // return stack
    uint pRst;
    uint dev[256];  // device data
    uint deviceFlags;
} uxn;

layout(binding = 1, rgba8) uniform image2D background;
layout(binding = 2, rgba8) uniform image2D foreground;

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// System Device Addresses
#define SYS_R 0x08
#define SYS_G 0x0a
#define SYS_B 0x0c
// Screen Device Addresses
#define SCREEN_VEC      0x20
#define SCREEN_WIDTH    0x22
#define SCREEN_HEIGHT   0x24
#define SCREEN_AUTO     0x26
#define SCREEN_X        0x28
#define SCREEN_Y        0x2a
#define SCREEN_ADDR     0x2c
#define SCREEN_PIXEL    0x2e
#define SCREEN_SPRITE   0x2f
// Flags
#define DEO_FLAG         0x001
#define DRAW_PIXEL_FLAG  0x010
#define DRAW_SPRITE_FLAG 0x100
// Pixel Modes
#define PIXEL_BACKGROUND_MASK 0x00
#define PIXEL_FOREGROUND_MASK 0x40

uint get_byte(uint addr) {
    return uxn.dev[addr];
}

uint get_short(uint addr) {
    return (uxn.dev[addr] << 8) + uxn.dev[addr + 1];
}

bool mask(uint x, uint mask) {
    return (x & mask) == mask;
}

//TODO decide on a spelling of color/colour and stick to it
vec4 get_colour(uint colour_i) {
    if (colour_i < 4) {
        uint shift = (3 - colour_i) * 4;
        uint r = (get_short(SYS_R) >> shift) & 0xF;
        uint g = (get_short(SYS_G) >> shift) & 0xF;
        uint b = (get_short(SYS_B) >> shift) & 0xF;
        uvec3 sys_colours = uvec3(r, g, b);
        return vec4(sys_colours.xyz / 16.0, 1.0);
    }
    return vec4(1.0, 0.0, 0.0, 1.0);
}

uint get_sprite_colour1(uint sprite_low) {
    if (sprite_low == 0x0) {
        return 10; // 'none'
    }
    return (sprite_low >> 2) & 0x3; // Extract bits [3:2]
}

uint get_sprite_colour0(uint sprite_low) {
    if (sprite_low == 0x0 || sprite_low == 0x5 || sprite_low == 0xa || sprite_low == 0xf) {
        return 10; // 'clear' or 'none'
    }
    return sprite_low & 0x3; // Extract bits [1:0]
}

void main() {
    // pixel requested
    if (mask(uxn.deviceFlags,DRAW_PIXEL_FLAG) && (gl_GlobalInvocationID.xy == vec2(0, 0))) {
        // coordinates
        uint x = get_short(SCREEN_X);
        uint y = get_short(SCREEN_Y);
        ivec2 coords = ivec2(x, y);

        // colour
        uint pixel = get_byte(SCREEN_PIXEL);
        vec4 color = get_colour(pixel & 0x0f);

        // editing the image
        if (pixel / 0x10 == 0x0) {
            imageStore(background, coords, color);
            uxn.deviceFlags |= 0x1000;
        }
        if (pixel / 0x10 == 0x4) {
            imageStore(foreground, coords, color);
            uxn.deviceFlags |= 0x2000;
        }
    }
    // sprite requested
    if (mask(uxn.deviceFlags, DRAW_SPRITE_FLAG)) {
        // ---------------------- 1 bpp --------------------------------
        // todo finish this
        uint row = get_byte(get_short(SCREEN_ADDR) + gl_GlobalInvocationID.x);
        uint sprite = get_byte(SCREEN_SPRITE);

        // flipped, modes and layer
        uint mode_is_2bpp = (sprite >> 11) & 1;
        uint layer_is_foreground = (sprite >> 10) & 1;

        // coordinates
        uint x = get_short(SCREEN_X);
        uint y = get_short(SCREEN_Y);
        uint y_flipped = (sprite >> 9) & 1;
        uint x_flipped = (sprite >> 8) & 1;
        ivec2 coords;
        coords.x = int(x + ((1 - x_flipped) * gl_GlobalInvocationID.x)
                         + (x_flipped * (8 - gl_GlobalInvocationID.x)));
        coords.y = int(y + ((1 - y_flipped) * gl_GlobalInvocationID.y)
                         + (y_flipped * (8 - gl_GlobalInvocationID.y)));

        // choosing the bpp mode
        if (mode_is_2bpp == 1) {
            return; //todo 2bpp sprites
        } else {
            // 1bpp
            uint draw_colour = (row >> uint(gl_GlobalInvocationID.x)) & 1; // for 1 bpp

            // select colour
            if (draw_colour == 1) {  // colour 1
                uint colour_1 = get_sprite_colour1(sprite & 0xf);
                if (colour_1 == 10) { return; }

                vec4 v_color_1 = get_colour(colour_1);
                if (layer_is_foreground == 1) {
                    imageStore(foreground, coords, v_color_1);
                } else {
                    imageStore(background, coords, v_color_1);
                }
            } else {  // colour 0
                uint colour_0 = get_sprite_colour0(sprite & 0xf);
                if (colour_0 == 10) { return; }

                vec4 v_color_0 = get_colour(colour_0);
                if (layer_is_foreground == 1) {
                    imageStore(foreground, coords, v_color_0);
                } else {
                    imageStore(background, coords, v_color_0);
                }
            }
        }
    }
}
