
Flags will be represented by uint 32: 0x[00][00][00][00]
 - first bite:  CPU synchronization bits (console, keyboard, mouse)
 - second bite: graphics
    - 0xaa: draw pixel
    - 0xbb: draw sprite


   0    0    0    0
0000 0000 0000 0000

a = xxxx xxxx 1011 1011 (xxbb)

a & 0000 0000 1111 1111

desired flag: xxxx xxxx 1010 1010
              0000 0000 1010 1010
           &  =         1010 1010
           ==

to test for flag: bitwise and with the mask then do equal

C example:
bool check_flag(uint32 x, uint32 cond) {
    return (x & cond) == cond;
}

x --> y
0 1 2 3 --> 3 2 1 0

y = 3 - x

Sprite
00000001:  01
00000010:  02
00000100:  04
10001000:  88
11010000:  d0
11100000:  e0
11110000:  f0
11111000:  f8

row & 0b00000001 -> get the digit

invocation ID x: selects the digit
              y: selects the row

get coords: x + invocationID.x, y + invocationID.y
get row: uint row = get_byte(addr + invocationID.y)
get digit: bool doDraw = (row >> invocationID.x) & 1;


/* | sprite low | 1       | 0       |
           |------------|---------|---------|
           | 0000       | clear   | none    |
           | 0001       | color1  | color0  |
           | 0010       | color2  | color0  |
           | 0011       | color3  | color0  |
           | 0100       | color0  | color1  |
           | 0101       | color1  | none    |
           | 0110       | color2  | color1  |
           | 0111       | color3  | color1  |
           | 1000       | color0  | color2  |
           | 1001       | color1  | color2  |
           | 1010       | color2  | none    |
           | 1011       | color3  | color2  |
           | 1100       | color0  | color3  |
           | 1101       | color1  | color3  |
           | 1110       | color2  | color3  |
           | 1111       | color3  | none    | */


void get_sprite_colors(int sprite_low, int *color1, int *color0) {
    // Extract color1 (higher bit) and color0 (lower bit)
    *color1 = (sprite_low >> 2) & 0x3;  // Extract bits [3:2]
    *color0 = sprite_low & 0x3;         // Extract bits [1:0]

    // Handle "none" cases where a color should be ignored
    if (sprite_low == 0x0) { // 0000: clear, none
        *color1 = -1;  // Indicate "clear"
        *color0 = -1;  // Indicate "none"
    } else if (sprite_low == 0x5 || sprite_low == 0xA || sprite_low == 0xF) {
        *color0 = -1; // Indicate "none" for specific cases
    }
}

int main() {
    int sprite_low = 0xA;  // Example input (binary 1010)
    int color1, color0;

    get_sprite_colors(sprite_low, &color1, &color0);

    // Print the result
    printf("sprite_low: 0x%X -> color1: %s, color0: %s\n", sprite_low,
           (color1 == -1) ? "none" : (color1 == 0) ? "color0" :
           (color1 == 1) ? "color1" : (color1 == 2) ? "color2" : "color3",
           (color0 == -1) ? "none" : (color0 == 0) ? "color0" :
           (color0 == 1) ? "color1" : (color0 == 2) ? "color2" : "color3");

    return 0;
}



